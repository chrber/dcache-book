<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                         "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % sharedents SYSTEM "shared-entities.xml" >
<!ENTITY executable   "<literal>executable</literal>">
<!ENTITY put   "<literal>PUT</literal>">
<!ENTITY get   "<literal>GET</literal>">
<!ENTITY remove   "<literal>REMOVE</literal>">
<!ENTITY storefile   "<literal>STORE FILE</literal>">
<!ENTITY fetchfile   "<literal>FETCH FILE</literal>">
<!ENTITY removefile   "<literal>REMOVE FILE</literal>">
<!ENTITY dc-prompt-pool1  "<prompt>(pool_1) admin &gt;</prompt>">
%sharedents;
]>

<chapter id="cf-tss">
  <title>The &dcache; Tertiary Storage System Interface</title>

  <section>
    <title>Introduction</title>
    <para>
      One of the features &dcache; provides is the ability to migrate
      files from its disk repository to one or more connected Tertiary
      Storage Systems (&tss;) and to move them back to disk when
      necessary. Although the interface between &dcache; and the &tss;
      is kept simple, &dcache; assumes to interact with an intelligent
      &tss;. &dcache; does not drive tape robots or tape drives by
      itself. More detailed requirements to the storage system are
      described in one of the subsequent paragraphs.
    </para>
  </section>

  <section>
    <title>Scope of this chapter</title>
    <para>
      This document describes how to enable a standard &dcache;
      installation to interact with a Tertiary Storage System. 
      In this description we assume that
      <itemizedlist>
	<listitem>
	  every &dcache; disk pool is connected to only one &tss; instance.
	</listitem>
	<listitem>
	  all &dcache; disk pools are connected to the same &tss; instance.
	</listitem>
	<listitem>
	  the &dcache; instance has not yet been populated with data,
	  or only with a negligible amount of files.
	</listitem>
      </itemizedlist>
      In general, not all pools need to be configured to interact with
      the same Tertiary Storage System or with a storage system at
      all. Furthermore pools can be configured to have more than one
      Tertiary Storage System attached, but all those cases are not in
      the scope of the document.
    </para>
  </section>

  <section id="cf-tss-hsm-requirements">
    <title>Requirements for a Tertiary Storage System</title>

    <para>
      &dcache; can only drive intelligent Tertiary Storage
      Systems. This essentially means that tape robot and tape drive
      operations must be done by the &tss; itself and that there is
      some simple way to abstract the file &put;,
      &get; and &remove; operation.
    </para>

    <section>
      <title>Migrating Tertiary Storage Systems with a file system
      interface.</title>
      <para>
	Most migrating storage systems provide a regular POSIX file
	system interface. Based on rules, data is migrated from
	primary to tertiary storage (mostly tape systems). Examples
	for migrating storage systems are:
	<itemizedlist>
	  <listitem>
	    <ulink
	    url="http://www.hpss-collaboration.org/">HPSS</ulink>
	    (High Performance Storage System)
	  </listitem>
	  <listitem>
	    <ulink
	    url='http://www.sgi.com/products/storage/software/dmf.html'>DMF</ulink>
	    (Data Migration Facility)
	  </listitem>
	</itemizedlist>
      </para>
    </section>

    <section>
      <title>Tertiary Storage Systems with a minimalistic &put;, &get;
      and &remove; interface</title>

      <para>
	Some tape systems provide a simple &put;,
	&get;, &remove;
	interface. Typically, a copy-like application writes a disk
	file into the &tss; and returns an identifier which uniquely
	identifies the written file within the Tertiary Storage
	System. The identifier is sufficient to get the file back to
	disk or to remove the file from the &tss;. Examples are:
	<itemizedlist>
	  <listitem>
	    <ulink
	    url='http://www.qstar.com/qstar-products/qstar-object-storage-manager'>OSM</ulink>
	    (Object Storage Manager)
	  </listitem>
	  <listitem>
	    <ulink
	    url='http://www-ccf.fnal.gov/enstore/'>Enstore</ulink>
	    (FERMIlab)
	  </listitem>
	</itemizedlist>
      </para>
    </section>

  </section>

  <section>
    <title>How &dcache; interacts with a Tertiary Storage System</title>

    <para>
      Whenever &dcache; decides to copy a file from disk to
      tertiary storage a user-provided <link
      linkend='tss-executable'>&executable;</link> which can be either
      a script or a binary is automatically started on the pool where
      the file is located. That &executable; is expected to write the
      file into the Backend Storage System and to return a URI,
      uniquely identifying the file within that storage system. The
      format of the URI as well as the arguments to the &executable;,
      are described later in this document. The unique part of the URI
      can either be provided by the storage element, in return of the
      &storefile; operation, or can be taken from &dcache;. A
      non-error return code from the &executable; lets &dcache; assume
      that the file has been successfully stored and, depending on the
      properties of the file, &dcache; can decide to remove the disk
      copy if space is running short on that pool. On a non-zero
      return from the &executable;, the file doesn't change its state
      and the operation is retried or an error flag is set on the
      file, depending on the error <link
      linkend='cf-tss-support-return-codes'>return code</link> from
      the &executable;.
    </para>

    <para>
      If &dcache; needs to restore a file to disk the same
      &executable; is launched with a different set of arguments,
      including the URI, provided when the file was written to
      tape. It is in the responsibility of the &executable; to fetch
      the file back from tape based on the provided URI and to return
      <literal>0</literal> if the &fetchfile; operation was successful
      or non-zero otherwise. In case of a failure the pool retries
      the operation or &dcache; decides to fetch the file from tape
      using a different pool.
    </para>
  </section>

  <section id='cf-tss-support'>
    <title>Details on the &tss;-support &executable;</title>

    <section id='cf-tss-support-clo'>
      <title>Summary of command line options</title>

      <para>
	This part explains the syntax of calling the &executable; that
	supports &storefile;, <literal>FETCH
	FILE</literal> and &removefile;
	operations.
      </para>

      <cmdsynopsis>
	<command>put</command>
	<arg choice='plain'><replaceable>pnfsID</replaceable></arg>
	<arg choice='plain'><replaceable>filename</replaceable></arg>
	<arg choice='plain'>-si=<replaceable>storage-information</replaceable></arg>
	<arg rep='repeat' choice='opt'><replaceable>other-options</replaceable></arg>
      </cmdsynopsis>
      <cmdsynopsis>
	<command>get</command>
	<arg choice='plain'><replaceable>pnfsID</replaceable></arg>
	<arg choice='plain'><replaceable>filename</replaceable></arg>
	<arg choice='plain'>-si=<replaceable>storage-information</replaceable></arg>
	<arg choice='plain'>-uri=<replaceable>storage-uri</replaceable></arg>
	<arg rep='repeat' choice='opt'><replaceable>other-options</replaceable></arg>
      </cmdsynopsis>
      <cmdsynopsis>
	<command>remove</command>
	<arg choice='plain'>-uri=<replaceable>storage-uri</replaceable></arg>
	<arg rep='repeat' choice='opt'><replaceable>other-options</replaceable></arg>
      </cmdsynopsis>

      <itemizedlist>
	<listitem>
	  <command>put</command> / <command>get</command> / <command>remove</command>:
	  these keywords indicate the operation to be performed.
	  <itemizedlist>
	    <listitem>
	      <command>put</command>: copy file from disk to &tss;.
	    </listitem>
	    <listitem>
	      <command>get</command>: copy file back from &tss; to disk.
	    </listitem>
	    <listitem>
	      <command>remove</command>: remove the file from &tss;.
	    </listitem>
	  </itemizedlist>
	</listitem>
	<listitem>
	  <replaceable><link
	  linkend='cf-chimera-ids'>pnfsID</link></replaceable>: The
	  internal identifier (i-node) of the file within
	  &dcache;. The <replaceable>pnfsID</replaceable> is unique
	  within a single &dcache; instance and globally unique with a
	  very high probability.
	</listitem>
	<listitem>
	  <replaceable>filename</replaceable>: is the full path of the
	  local file to be copied to the &tss; (for
	  <command>put</command>) and respectively into which the file
	  from the &tss; should be copied (for
	  <command>get</command>).
	</listitem>
	<listitem>
	  <replaceable>storage-information</replaceable>:
	  the storage information of the file, as explained <link
	  linkend='cf-tss-support-storage-info'>below</link>.
	</listitem>
	<listitem>
	  <link
	  linkend='cf-tss-support-storage-uri'><replaceable>storage-uri</replaceable></link>:
	  the URI, which was returned by the &executable;, after the
	  file was written to tertiary storage. In order to get the
	  file back from the &tss; the information of the URI is
	  preferred over the information in the
	  <replaceable>storage-information</replaceable>.
	</listitem>
	<listitem>
	  <replaceable>other-options</replaceable>:
	  -<replaceable>key</replaceable> =
	  <replaceable>value</replaceable> pairs taken from the &tss;
	  configuration commands of the pool 'setup' file. One of the
	  options, always provided is the option -command=<replaceable>full
	  path of this &executable;</replaceable>.
	</listitem>
      </itemizedlist>

      <section id='cf-tss-support-storage-info'>
	<title>Storage Information</title>

	<para>
	  The <replaceable>storage-information</replaceable> is a
	  string in the format
	  <programlisting>-si=size=<replaceable>bytes</replaceable>;new=<replaceable>true/false</replaceable>;stored=<replaceable>true/false</replaceable>;sClass=<replaceable>StorageClass</replaceable>;\
cClass0<replaceable>CacheClass</replaceable>;hsm=<replaceable>StorageType</replaceable>;<replaceable>key</replaceable>=<replaceable>value</replaceable>;[<replaceable>key</replaceable>=<replaceable>value</replaceable>;[...]]</programlisting>
	</para>
	<informalexample>
	  <programlisting>-si=size=1048576000;new=true;stored=false;sClass=desy:cms-sc3;cClass=-;hsm=osm;Host=desy;</programlisting>
	</informalexample>

	<itemizedlist>
	  <title>Mandatory storage information's keys</title>
	  <listitem>
	    <replaceable>size</replaceable>: Size of the file in bytes
	  </listitem>
	  <listitem>
	    <replaceable>new</replaceable>: &false; if file already in
	    the &dcache;; &true; otherwise
	  </listitem>
	  <listitem>
	    <replaceable>stored</replaceable>: &true; if file already
	    stored in the &tss;; &false; otherwise
	  </listitem>
	  <listitem>
	    <replaceable>sClass</replaceable>: &hsm; depended, is used by the
	    &serv-poolmngr; for pool attraction.
	  </listitem>
	  <listitem>
	    <replaceable>cClass</replaceable>: Parent directory tag
	    (cacheClass). Used by the &serv-poolmngr; for pool
	    attraction. May be '-'.
	  </listitem>
	  <listitem>
	    <replaceable>hsm</replaceable>: Storage manager name
	    (enstore/osm). Can be overwritten by the parent directory
	    tag (hsmType).
	  </listitem>
	</itemizedlist>

	<itemizedlist>
	  <title>OSM specific storage information's keys</title>
	  <listitem>
	    <replaceable>group</replaceable>: The storage group of the file to
	    be stored as specified in the ".(tag)(sGroup)" tag of the
	    parent directory of the file to be stored.
	  </listitem>
	  <listitem>
	    <replaceable>store</replaceable>: The store name of the file to be
	    stored as specified in the ".(tag)(OSMTemplate)" tag of
	    the parent directory of the file to be stored.
	  </listitem>
	  <listitem>
	    <replaceable>bfid</replaceable>: Bitfile ID (get and remove only)
	    (e.g. 000451243.2542452542.25424524)
	  </listitem>
	</itemizedlist>

	<itemizedlist>
	  <title>Enstore specific storage information's keys</title>
	  <listitem>
	    <replaceable>group</replaceable>: The storage group (e.g. cdf, cms
	    ...)
	  </listitem>
	  <listitem>
	    <replaceable>family</replaceable>: The file family
	    (e.g. sgi2test, h6nxl8, ...)
	  </listitem>
	  <listitem>
	    <replaceable>bfid</replaceable>: Bitfile ID (get only)
	    (e.g. B0MS105746894100000)
	  </listitem>
	  <listitem>
	    <replaceable>volume</replaceable>: Tape Volume (get only)
	    (e.g. IA6912)
	  </listitem>
	  <listitem>
	    <replaceable>location</replaceable>: Location on tape (get only)
	    (e.g. : 0000_000000000_0000117)
	  </listitem>
	</itemizedlist>

	<para>
	  There might be more key values pairs which are used by the
	  &dcache; internally and which should not affect the
	  behaviour of the &executable;.
	</para>

      </section>



      <section id='cf-tss-support-storage-uri'>
	<title>Storage URI</title>

	<para>
	  The <replaceable>storage-uri</replaceable> is formatted as
	  follows:
	</para>

	<para>
	  <programlisting><uri>hsmType://hsmInstance/?store=<replaceable>storename</replaceable>&amp;group=<replaceable>groupname</replaceable>&amp;bfid=<replaceable>bfid</replaceable></uri></programlisting>
	</para>

	<itemizedlist>
	  <listitem>
	    <replaceable>hsmType</replaceable>: The type of the
	    Tertiary Storage System
	  </listitem>
	  <listitem>
	    <replaceable>hsmInstance</replaceable>: The name of the instance
	  </listitem>
	  <listitem>
	    <replaceable>storename</replaceable> and
	    <replaceable>groupname</replaceable> : The store and group
	    name of the file as provided by the arguments to this
	    &executable;.
	  </listitem>
	  <listitem>
	    <replaceable>bfid</replaceable>: The unique identifier
	    needed to restore or remove the file if necessary.
	  </listitem>
	</itemizedlist>

	<informalexample>
	  <para>
	    A storage-uri:
	  </para>
	  <programlisting><uri>osm://osm/?store=sql&amp;group=chimera&amp;bfid=3434.0.994.1188400818542</uri></programlisting>
	</informalexample>

      </section>

    </section>

    <section id='cf-tss-support-return-codes'>
      <title>Summary of return codes</title>

      <informaltable>
	<tgroup cols="4" align="left">
	  <colspec colnum="1"  colwidth="*"/>
	  <colspec colnum="2"  colwidth="*"/>
	  <colspec colnum="3"  colwidth="*"/>
	  <colspec colnum="4"  colwidth="*"/>
	  <thead>
	    <row>
	      <entry>Return Code</entry>
	      <entry>Meaning</entry>
	      <entry>Behaviour for PUT FILE</entry>
	      <entry>Behaviour for GET FILE</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>
		30 &lt;= rc &lt; 40
	      </entry>
	      <entry>
		User defined
	      </entry>
	      <entry>
		Deactivates request
	      </entry>
	      <entry>
		Reports problem to &serv-poolmngr;
	      </entry>
	    </row>
	    <row>
	      <entry>
		41
	      </entry>
	      <entry>
		No space left on device
	      </entry>
	      <entry>
		Pool retries
	      </entry>
	      <entry>
		Disables pool and reports problem to &serv-poolmngr;
	      </entry>
	    </row>
	    <row>
	      <entry>
		42
	      </entry>
	      <entry>
		Disk read I/O error
	      </entry>
	      <entry>
		Pool retries
	      </entry>
	      <entry>
		Disables pool and reports problem to &serv-poolmngr;
	      </entry>
	    </row>
	    <row>
	      <entry>
		43
	      </entry>
	      <entry>
		Disk write I/O error
	      </entry>
	      <entry>
		Pool retries
	      </entry>
	      <entry>
		Disables pool and reports problem to &serv-poolmngr;
	      </entry>
	    </row>
	    <row>
	      <entry>
		other
	      </entry>
	      <entry>
		-
	      </entry>
	      <entry>
		Pool retries
	      </entry>
	      <entry>
		Reports problem to &serv-poolmngr;
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

    </section>

    <section>
      <title>The &executable; and the &storefile;
      operation</title>

      <para>
	Whenever a disk file needs to be copied to a Tertiary Storage
	System &dcache; automatically launches an &executable; on the
	pool containing the file to be copied. Exactly one instance
	of the &executable; is started for each file. Multiple
	instances of the &executable; may run concurrently for
	different files. The maximum number of concurrent instances of
	the <literal>&executable;s</literal> per pool as well as the
	full path of the &executable; can be configured in the 'setup'
	file of the pool as described in <xref
	linkend='cf-tss-pools-layout-setup'/>.
      </para>


      <para>
	The following arguments are given to the &executable; of a
	&storefile; operation on startup.
	<cmdsynopsis>
	  <command>put</command>
	  <arg choice='plain'><replaceable>pnfsID</replaceable></arg>
	  <arg choice='plain'><replaceable>filename</replaceable></arg>
	  <arg choice='plain'>-si=<replaceable>storage-information</replaceable></arg>
	  <arg choice='plain'><replaceable>more options</replaceable></arg>
	</cmdsynopsis>
	Details on the meaning of certain arguments are described in
	<xref linkend='cf-tss-support-clo'/>.
      </para>
      <para>
	With the arguments provided the &executable; is supposed to
	copy the file into the Tertiary Storage System. The
	&executable; must not terminate before the transfer of the
	file was either successful or failed.
      </para>
      <para>
	Success must be indicated by a <literal>0</literal> return of
	the &executable;. All non-zero values are interpreted as a
	failure which means, &dcache; assumes that the file has not
	been copied to tape.
      </para>
      <para>
	In case of a <literal>0</literal> return code the &executable;
	has to return a valid storage URI to &dcache; in formate:
      </para>
      <programlisting><uri>hsmType://hsmInstance/?store=<replaceable>storename</replaceable>&amp;group=<replaceable>groupname</replaceable>&amp;bfid=<replaceable>bfid</replaceable></uri></programlisting>
      <para>
	Details on the meaning of certain parameters are described
	<link linkend='cf-tss-support-storage-uri'>above</link>.
      </para>

      <para>
	The <replaceable>bfid</replaceable> can either be provided by
	the &tss; as result of the &storefile;
	operation or the <literal>pnfsID</literal> may be used. The
	latter assumes that the file has to be stored with exactly
	that <literal>pnfsID</literal> within the &tss;. Whatever URI
	is chosen, it must allow to uniquely identify the file within
	the Tertiary Storage System.
      </para>

      <note>
	<para>
	  Only the URI must be printed to stdout by the
	  &executable;. Additional information printed either before
	  or after the URI will result in an error. stderr can be used
	  for additional debug information or error messages.
	</para>
      </note>
    </section>



    <section>
      <title>The &executable; and the &fetchfile; operation</title>
      <para>
	Whenever a disk file needs to be restored from a Tertiary
	Storage System &dcache; automatically launches an
	&executable; on the pool containing the file to be
	copied. Exactly one instance of the &executable; is started
	for each file. Multiple instances of the &executable; may run
	concurrently for different files. The maximum number of
	concurrent instances of the &executable; per pool as well as
	the full path of the &executable; can be configured in the
	'setup' file of the pool as described in <xref
	linkend='cf-tss-pools-layout-setup'/>.
      </para>

      <para>
	The following arguments are given to the &executable; of a
	&fetchfile; operation on startup:
	<cmdsynopsis>
	  <command>get</command>
	  <arg choice='plain'><replaceable>pnfsID</replaceable></arg>
	  <arg choice='plain'><replaceable>filename</replaceable></arg>
	  <arg choice='plain'>-si=<replaceable>storage-information</replaceable></arg>
	  <arg choice='plain'>-uri=<replaceable>storage-uri</replaceable></arg>
	  <arg choice='plain'><replaceable>more options</replaceable></arg>
	</cmdsynopsis>
	Details on the meaning of certain arguments are described in
	<xref linkend="cf-tss-support-clo"/>. For return codes see
	<xref linkend="cf-tss-support-return-codes"/>.
      </para>
    </section>

    <section>
      <title>The &executable; and the &removefile;
      operation</title>
      <para>
	Whenever a file is removed from the &dcache; namespace (file
	system) a process inside &dcache; makes sure that all copies
	of the file are removed from all internal and external
	media. The pool which is connected to the &tss; which stores
	the file is activating the &executable; with
	the following command line options:
	<cmdsynopsis>
	  <command>remove</command>
	  <arg choice='plain'>-uri=<replaceable>storage-uri</replaceable></arg>
	  <arg choice='plain'><replaceable>more options</replaceable></arg>
	</cmdsynopsis>

	Details on the meaning of certain arguments are described in
	<xref linkend="cf-tss-support-clo"/>. For return codes see
	<xref linkend="cf-tss-support-return-codes"/>.
      </para>
      <para>
	The &executable; is supposed to remove the
	file from the &tss; and report a zero return code. If a
	non-zero error code is returned, the &dcache; will call the
	script again at a later point in time.
      </para>
    </section>


  </section>

  <section id='cf-tss-pools'>
    <title>Configuring pools to interact with a Tertiary Storage System</title>
    <para>
      The &executable; interacting with the Tertiary
      Storage System (&tss;), as described in the chapter above, has
      to be provided to &dcache; on all pools connected to the
      &tss;. The &executable;, either a script or a
      binary, has to be made <quote>executable</quote> for the user,
      &dcache; is running as, on that host.
    </para>

    <para>
      The following files have to be modified to allow &dcache; to
      interact with the &tss;.
    </para>
    <itemizedlist>
      <listitem>
	The <filename>PoolManager.conf</filename> file (one per
	system)
      </listitem>
      <listitem>
	The pool layout file (one per pool host)
      </listitem>
      <listitem>
	The pool 'setup' file (one per pool)
      </listitem>
      <listitem>
	The namespaceDomain layout file (one per system)
      </listitem>
    </itemizedlist>
    <para>
      After the layout files and the various 'setup' files have been
      corrected, the following domains have to be restarted :
    </para>
    <itemizedlist>
      <listitem>
	pool services
      </listitem>
      <listitem>
	dCacheDomain
      </listitem>
      <listitem>
	namespaceDomain
      </listitem>
    </itemizedlist>

    <section id='cf-tss-pools-layout'>
      <title>The &dcache; layout files</title>

      <section>
	<title>The <filename>PoolManager.conf</filename> file</title>
	<para>
	  To be able to read a file from the tape in case the cached
	  file has been deleted from all pools, enable the
	  restore-option. The best way to do this is to log in to the
	  Admin Interface and run the following commands:
	</para>
	  <programlisting>[example.dcache.org] &dc-prompt-local; cd &cell-poolmngr;
[example.dcache.org] &dc-prompt-pm; pm set -stage-allowed=yes
[example.dcache.org] &dc-prompt-pm; save</programlisting>
        <para>
          A restart of the &domain-dcache; is not necessary in this case.
	</para>

	 <para>
	   Alternatively, if the file
	   <filename>&path-odc-ed;/PoolManager.conf</filename> already
	   exists then you can add the entry
	 </para>
	 <programlisting>pm set -stage allowed=yes</programlisting>
	 <para>
	   and restart the &domain-dcache;.
	 </para>

	 <warning>
	   Do not create the file
	   <filename>&path-odc-ed;/PoolManager.conf</filename>
	   with this single entry! This will result in an error.
	 </warning>

      </section>

      <section>
	<title>The pool layout</title>
	<para>
	  The &dcache; layout file must be modified for each pool node
	  connected to a &tss;. If your pool nodes have been
	  configured correctly to work without &tss;, you will find
	  the entry <literal>lfs=precious</literal> in the layout file
	  (that is located in <filename
	  class='directory'>&path-ode-ed;/layouts</filename> and in
	  the file <filename>&path-ode-ed;/dcache.conf</filename>
	  respectively) for each pool service. This entry is a
	  disk-only-option and has to be removed for each pool which
	  should be connected to a &tss;. This will default the
	  <literal>lfs</literal> parameter to <literal>hsm</literal>
	  which is exactly what we need.
	</para>
      </section>

      <section id='cf-tss-pools-layout-setup'>
	<title>The pool 'setup' file</title>
	<para>
	  The pool 'setup' file is the file
	  <filename>$poolHomeDir/$poolName/setup</filename>. It mainly
	  defines 3 details related to &tss; connectivity.
	</para>

	<itemizedlist>
	  <listitem>
	    Pointer to the &executable; which is
	    launched on storing and fetching files.
	  </listitem>
	  <listitem>
	    The maximum number of concurrent &storefile; requests
	    allowed per pool.
	  </listitem>
	  <listitem>
	    The maximum number of concurrent &fetchfile; requests
	    allowed per pool.
	  </listitem>
	</itemizedlist>

	<para>
	  Define the &executable; and Set the maximum number of
	  concurrent &put; and &get; operations:
	</para>
	<programlisting>hsm set <replaceable>hsmType</replaceable> [<replaceable>hsmInstanceName</replaceable>] [-command=<replaceable>/path/to/executable</replaceable>] [-key=<replaceable>value</replaceable>]

#
#  PUT operations
# set the maximum number of active PUT operations >= 1
#
st set max active <replaceable>numberOfConcurrentPUTS</replaceable>

#
# GET operations
# set the maximum number of active GET operations >= 1
#
rh set max active <replaceable>numberOfConcurrentGETs</replaceable></programlisting>


	<itemizedlist>
	  <listitem>
	    <replaceable>hsmType</replaceable>: the type ot the &tss;
	    system. Must be set to <quote>osm</quote> for basic
	    setups.
	  </listitem>
	  <listitem>
	    <replaceable>hsmInstanceName</replaceable>: the instance name
	    of the &tss; system. Must be set to <quote>osm</quote> for
	    basic setups.
	  </listitem>
	  <listitem>
	    <replaceable>/path/to/executable</replaceable>: the
	    full path to the &executable; which
	    should be launched for each &tss; operation.
	  </listitem>
	</itemizedlist>
	<para>
	  Setting the maximum number of concurrent
	  &put; and &get;
	  operations.
	</para>


        <para>
	  Both numbers must be non zero to allow the pool to perform
	  transfers.
	</para>

	<informalexample>
	  <para>
	    We provide a <link linkend='tss-executable'>script</link>
	    to simulate a connection to a &tss;.  To use this script
	    place it in the directory <filename
	    class='directory'>&path-odj-usdl;</filename>, and create
	    a directory to simulate the base of the &tss;.
	  </para>
	  <programlisting>&prompt-root; <userinput>mkdir -p /hsmTape/data</userinput></programlisting>

	  <para>
	    Login to the Admin Interface to change the entry of the
	    pool 'setup' file for a pool named pool_1.
	  </para>

	  <programlisting>&dc-prompt-local; cd pool_1
&dc-prompt-pool1; hsm set osm osm 
&dc-prompt-pool1; hsm set osm -command=&path-odj-usdl;/hsmscript.sh
&dc-prompt-pool1; hsm set osm -hsmBase=/hsmTape
&dc-prompt-pool1; st set max active 5
&dc-prompt-pool1; rh set max active 5
&dc-prompt-pool1; save</programlisting>
	</informalexample>

      </section>

      <section>
	<title>The namespace layout</title>
	<para>
	  In order to allow &dcache; to remove files from attached
	  &tss;es, the <quote>cleaner.hsm = enabled</quote> must be
	  added immediately underneath the [namespaceDomain/cleaner]
	  service declaration:
	</para>
	<programlisting>[namespaceDomain]
 ... other services ...
[namespaceDomain/cleaner]
cleaner.hsm = enabled
.. more ...</programlisting>

      </section>

    </section>

    <section>
      <title>What happens next</title>
      <para>
	After restarting the necessary &dcache; domains, pools,
	already containing files, will start transferring them into
	the &tss; as those files only have a disk copy so far. The
	number of transfers is determined by the configuration in the
	pool 'setup' file as described above in <xref
	linkend="cf-tss-pools-layout-setup"/>.
      </para>

    </section>
  </section>

  <section id='cf-tss-pools-admin'>
    <title>How to Store-/Restore files via the Admin Interface</title>
    <para>
      In order to see the state of files within a pool, login into the
      pool in the admin interface and run the command <command>rep ls</command>.
    </para>
    <programlisting>[example.dcache.org] &dc-prompt-pool; rep ls</programlisting>
    <para>
      The output will have the following format:
    </para>
    <programlisting>PNFSID &lt;MODE-BITS(LOCK-TIME)[OPEN-COUNT]&gt; SIZE si={STORAGE-CLASS}</programlisting>

      <itemizedlist>
	<listitem>
	  PNFSID: The &pnfs;ID of the file
	</listitem>
	<listitem>
	  MODE-BITS: <programlisting>   CPCScsRDXEL
   |||||||||||
   ||||||||||+--  (L) File is locked (currently in use)
   |||||||||+---  (E) File is in error state
   ||||||||+----  (X) File is pinned (aka "sticky")
   |||||||+-----  (D) File is in process of being destroyed
   ||||||+------  (R) File is in process of being removed
   |||||+-------  (s) File sends data to back end store
   ||||+--------  (c) File sends data to client (&dcap;,&ftp;...)
   |||+---------  (S) File receives data from back end store
   ||+----------  (C) File receives data from client (&dcap;,&ftp;)
   |+-----------  (P) File is precious, i.e., it is only on disk
   +------------  (C) File is on tape and only cached on disk.</programlisting>
	</listitem>
	<listitem>
	  LOCK-TIME: The number of milli-seconds this file will still
	  be locked. Please note that this is an internal lock and not
	  the pin-time (&srm;).
	</listitem>
	<listitem>
	  OPEN-COUNT: Number of clients currently reading this file.
	</listitem>
	<listitem>
	  SIZE: File size
	</listitem>
	<listitem>
	  STORAGE-CLASS: The storage class of this file.
	</listitem>
      </itemizedlist>

    <informalexample>
      <programlisting>[example.dcache.org] &dc-prompt-pool1; rep ls
00008F276A952099472FAD619548F47EF972 &lt;-P---------L(0)[0]&gt; 291910 si={dteam:STATIC}
00002A9282C2D7A147C68A327208173B81A6 &lt;-P---------L(0)[0]&gt; 2011264 si={dteam:STATIC}
0000EE298D5BF6BB4867968B88AE16BA86B0 &lt;C----------L(0)[0]&gt; 1976 si={dteam:STATIC}</programlisting>
    </informalexample>


    <para>
      In order to <literal>flush</literal> a file to the tape run the
      command <command>flush pnfsid</command>.
    </para>
    <programlisting>[example.dcache.org] &dc-prompt-pool; flush pnfsid <replaceable>pnfsid</replaceable></programlisting>
    <informalexample>
      <programlisting>[example.dcache.org] &dc-prompt-pool1; flush pnfsid 00002A9282C2D7A147C68A327208173B81A6
Flush Initiated</programlisting>
    </informalexample>

    <para>
      A file that has been flushed to tape gets the flag 'C'. 
    </para>
    <informalexample>
      <programlisting>[example.dcache.org] &dc-prompt-pool1; rep ls
00008F276A952099472FAD619548F47EF972 &lt;-P---------L(0)[0]&gt; 291910 si={dteam:STATIC}
00002A9282C2D7A147C68A327208173B81A6 &lt;C----------L(0)[0]&gt; 2011264 si={dteam:STATIC}
0000EE298D5BF6BB4867968B88AE16BA86B0 &lt;C----------L(0)[0]&gt; 1976 si={dteam:STATIC}</programlisting>
    </informalexample>


    <para>
      To remove such a file from the repository run the command <command>rep rm</command>.
    </para>
    <programlisting>[example.dcache.org] &dc-prompt-pool; rep rm <replaceable>pnfsid</replaceable></programlisting>
    <informalexample>
      <programlisting>[example.dcache.org] &dc-prompt-pool1; rep rm  00002A9282C2D7A147C68A327208173B81A6
Removed 00002A9282C2D7A147C68A327208173B81A6</programlisting>
    </informalexample>

    <para>
      In this case the file will be restored when requested.
    </para>

    <para>
      To <literal>restore</literal> a file from the tape you can
      simply request it by initializing a reading transfer or you can
      fetch it by running the command <command>rh
      restore</command>.
    </para>
    <programlisting>[example.dcache.org] &dc-prompt-pool; rh restore [-block] <replaceable>pnfsid</replaceable></programlisting>
    <informalexample>
      <programlisting>[example.dcache.org] &dc-prompt-pool1; rh restore 00002A9282C2D7A147C68A327208173B81A6
Fetch request queued</programlisting>
    </informalexample>

  </section>

  <section id='cf-tss-monitor'>
    <title>How to monitor what's going on</title>
    <para>
      This section briefly describes the commands and mechanisms to
      monitor the &tss; &put;, &get; and &remove; operations. &dcache;
      provides a configurable logging facility and a Command Line
      Admin Interface to query and manipulate transfer and waiting
      queues.
    </para>

    <section id='cf-tss-monitor-log'>
      <title>Log Files</title>
      <para>
	By default &dcache; is configured to only log information if
	something unexpected happens. However, to get familiar with
	Tertiary Storage System interactions you might be interested
	in more details. This section provides advice on how to obtain
	this kind of information.
      </para>

      <section>
	<title>The &executable; log file</title>

	<para>
	  Since you provide the &executable;, interfacing &dcache; and
	  the &tss;, it is in your responsibility to ensure sufficient
	  logging information to be able to trace possible problems
	  with either &dcache; or the &tss;. Each request should be
	  printed with the full set of parameters it receives,
	  together with a timestamp. Furthermore information returned
	  to &dcache; should be reported.
	</para>
      </section>

      <section>
	<title>&dcache; log files in general</title>
	<para>
	  In &dcache;, each domain (e.g. &domain-dcache;,
	  &domain-pool; etc) prints logging information into its own
	  log file named after the domain. The location of those log
	  files it typically the <filename
	  class='directory'>/var/log</filename> or <filename
	  class='directory'>/var/log/dCache</filename> directory
	  depending on the individual configuration. In the default
	  logging setup only errors are reported. This behavior can be
	  changed by either modifying
	  <filename>&path-ode-ed;/logback.xml</filename> or using
	  the &dcache; CLI to increase the log level of particular
	  components as described <link
	  linkend='cf-tss-monitor-log-cli'>below</link>.
	</para>

      <section>
	<title>Increase the &dcache; log level by changes in
	<filename>&path-ode-ed;/logback.xml</filename></title>
	<para>
	  If you intend to increase the log level of all components on
	  a particular host you would need to change the
	  <filename>&path-ode-ed;/logback.xml</filename> file as
	  described below. &dcache; components need to be restarted to
	  activate the changes.
	</para>

	<programlisting><![CDATA[
<threshold>
     <appender>stdout</appender>
     <logger>root</logger>
     <level>warn</level>
   </threshold>]]>
</programlisting>

        <para>
	  needs to be changed to
	</para>

	<programlisting><![CDATA[
<threshold>
     <appender>stdout</appender>
     <logger>root</logger>
     <level>info</level>
   </threshold>]]></programlisting>

	<important>
	  <para>
	    The change might result in a significant increase in log
	    messages. So don't forget to change back before starting
	    production operation. The next section describes how to
	    change the log level in a running system.
	  </para>
	</important>
      </section>

      <section id='cf-tss-monitor-log-cli'>
	<title>Increase the &dcache; log level via the Command Line
	Admin Interface</title>

        <informalexample>
	  <para>
	    Login into the &dcache; Command Line Admin Interface and
	    increase the log level of a particular service, for
	    instance for the &serv-poolmngr; service:
	  </para>

	  <programlisting>[example.dcache.org] &dc-prompt-local; cd PoolManager
[example.dcache.org] &dc-prompt-pm; log set stdout ROOT INFO
[example.dcache.org] &dc-prompt-pm; log ls
stdout:
  ROOT=INFO
  dmg.cells.nucleus=WARN*
  logger.org.dcache.cells.messages=ERROR*
.....</programlisting>
	</informalexample>

      </section>
      </section>

    </section>


      <section id='cf-tss-monitor-clAdmin'>
	<title>Obtain information via the &dcache; Command Line Admin Interface</title>

	<para>
	  The &dcache; Command Line Admin Interface gives access to
	  information describing the process of storing and fetching
	  files to and from the &tss;, as there are:
	</para>

	<itemizedlist>
	  <listitem>
	    The <firstterm>Pool Manager Restore Queue</firstterm>. A
	    list of all requests which have been issued to all pools
	    for a &fetchfile; operation from the &tss; (rc ls)
	  </listitem>
	  <listitem>
	    The <firstterm>Pool Collector Queue</firstterm>. A list of
	    files, per pool and storage group, which will be scheduled
	    for a &storefile; operation as soon as the configured
	    trigger criteria match.
	  </listitem>
	  <listitem>
	    The <firstterm>Pool &storefile; Queue</firstterm>. A list
	    of files per pool, scheduled for the &storefile;
	    operation. A configurable amount of requests within this
	    queue are active, which is equivalent to the number of
	    concurrent store processes, the rest is inactive, waiting
	    to become active.
	  </listitem>
	  <listitem>
	    The <firstterm>Pool &fetchfile; Queue</firstterm>. A list
	    of files per pool, scheduled for the &fetchfile;
	    operation. A configurable amount of requests within this
	    queue are active, which is equivalent to the number of
	    concurrent fetch processes, the rest is inactive, waiting
	    to become active.
	  </listitem>
	</itemizedlist>

	<para>
	  For evaluation purposes, the <firstterm>pinboard</firstterm>
	  of each component can be used to track down &dcache;
	  behavior. The pinboard only keeps the most recent 200 lines
	  of log information but reports not only errors but
	  informational messages as well.
	</para>

	<informalexample>
	  <para>
	    Check the pinboard of a service, here the &serv-poolmngr; service.
	  </para>

	  <programlisting>[example.dcache.org] &dc-prompt-local; cd PoolManager
[example.dcache.org] &dc-prompt-pm; show pinboard 100
08.30.45  [Thread-7] [pool_1 PoolManagerPoolUp] sendPoolStatusRelay: ...
08.30.59  [writeHandler] [NFSv41-dcachetogo PoolMgrSelectWritePool ...
....</programlisting>
	</informalexample>



	<informalexample>
	  <formalpara><title>The &cell-poolmngr; Restore Queue</title>
	  <para>
	    Remove the file <filename>test.root</filename> with the
	    &pnfs;-ID 00002A9282C2D7A147C68A327208173B81A6.
	  </para>

	  <programlisting><prompt>[example.dcache.org] (pool_1) admin &gt;</prompt> rep rm  00002A9282C2D7A147C68A327208173B81A6</programlisting>
          <para>
	    Request the file <filename>test.root</filename>
	  </para>
	  <programlisting>&prompt-user; &path-oddb-n-s;dccp dcap://example.dcache.org:/data/test.root test.root</programlisting>
          <para>
	    Check the &cell-poolmngr; Restore Queue:
	  </para>
	  <programlisting>[example.dcache.org] &dc-prompt-local; cd PoolManager
[example.dcache.org] &dc-prompt-pm; rc ls
0000AB1260F474554142BA976D0ADAF78C6C@0.0.0.0/0.0.0.0-*/* m=1 r=0 [pool_1] [Staging 08.15 17:52:16] {0,}</programlisting>
	</formalpara>
	</informalexample>

	<informalexample>
	  <formalpara><title>The Pool Collector Queue</title>
	  </formalpara>

	  <programlisting>[example.dcache.org] &dc-prompt-local; cd pool_1
[example.dcache.org] &dc-prompt-pool1; queue ls -l queue
                   Name: chimera:alpha
              Class@Hsm: chimera:alpha@osm
 Expiration rest/defined: -39 / 0   seconds
 Pending   rest/defined: 1 / 0
 Size      rest/defined: 877480 / 0
 Active Store Procs.   :  0
  00001BC6D76570A74534969FD72220C31D5D


[example.dcache.org] &dc-prompt-pool1; flush ls
Class                 Active   Error  Last/min  Requests    Failed
dteam:STATIC@osm           0       0         0         1         0</programlisting>
	</informalexample>

	  <informalexample>
	  <formalpara><title>The pool &storefile; Queue</title>
	  </formalpara>

	    <programlisting>[example.dcache.org] &dc-prompt-local; cd pool_1
[example.dcache.org] &dc-prompt-pool1; st ls
0000EC3A4BFCA8E14755AE4E3B5639B155F9  1   Fri Aug 12 15:35:58 CEST 2011</programlisting>
	  </informalexample>

	<informalexample>
	  <formalpara><title>The pool &fetchfile; Queue</title>
	  </formalpara>

	  <programlisting>[example.dcache.org] &dc-prompt-local; cd pool_1
[example.dcache.org] &dc-prompt-pool1;  rh ls
0000B56B7AFE71C14BDA9426BBF1384CA4B0  0   Fri Aug 12 15:38:33 CEST 2011</programlisting>
	  </informalexample>

	  <para>
	    To check the repository on the pools run the command
	    <command>rep ls</command> that is described in the
	    beginning of <xref linkend='cf-tss-pools-admin'/>.
	  </para>

	</section>
      </section>

    <section id='tss-executable'>
      <title>Example of an &executable; to simulate a tape backend</title>
<!-- TODO Move to a better place -->

      <informalexample>
	<programlisting><![CDATA[#!/bin/sh
#
#set -x
#
logFile=/tmp/hsm.log
#
################################################################
#
#  Some helper functions
#
##.........................................
#
# print usage
#
usage() {
   echo "Usage : put|get <pnfsId> <filePath> [-si=<storageInfo>] [-key[=value] ...]" 1>&2
}
##.........................................
#
#
printout() {
#---------
   echo "$pnfsid : $1" >>${logFile}
   return 0
}
##.........................................
#
#  print error into log file and to stdout.
#
printerror() {
#---------

   if [ -z "$pnfsid" ] ; then
#      pp="000000000000000000000000000000000000"
      pp="------------------------------------"
   else
      pp=$pnfsid
   fi

   echo "$pp : (E) : $*" >>${logFile}
   echo "$pp : $*" 1>&2

}
##.........................................
#
#  find a key in the storage info
#
findKeyInStorageInfo() {
#-------------------

   result=`echo $si  | awk  -v hallo=$1 -F\; '{ for(i=1;i<=NF;i++){ split($i,a,"=") ; if( a[1] == hallo )print a[2]} }'`
   if [ -z "$result" ] ; then return 1 ; fi
   echo $result
   exit 0

}
##.........................................
#
#  find a key in the storage info
#
printStorageInfo() {
#-------------------
   printout "storageinfo.StoreName : $storeName"
   printout "storageinfo.store : $store"
   printout "storageinfo.group : $group"
   printout "storageinfo.hsm   : $hsmName"
   printout "storageinfo.accessLatency   : $accessLatency"
   printout "storageinfo.retentionPolicy : $retentionPolicy"
   return 0
}
##.........................................
#
#  assign storage info the keywords
#
assignStorageInfo() {
#-------------------

    store=`findKeyInStorageInfo "store"`
    group=`findKeyInStorageInfo "group"`
    storeName=`findKeyInStorageInfo "StoreName"`
    hsmName=`findKeyInStorageInfo "hsm"`
    accessLatency=`findKeyInStorageInfo "accessLatency"`
    retentionPolicy=`findKeyInStorageInfo "retentionPolicy"`
    return 0
}
##.........................................
#
# split the arguments into the options -<key>=<value> and the
# positional arguments.
#
splitArguments() {
#----------------
#
  args=""
  while [ $# -gt 0 ] ; do
    if expr "$1" : "-.*" >/dev/null ; then
       a=`expr "$1" : "-\(.*\)" 2>/dev/null`
       key=`echo "$a" | awk -F= '{print $1}' 2>/dev/null`
         value=`echo "$a" | awk -F= '{for(i=2;i<NF;i++)x=x $i "=" ; x=x $NF ; print x }' 2>/dev/null`
       if [ -z "$value" ] ; then a="${key}=" ; fi
       eval "${key}=\"${value}\""
       a="export ${key}"
       eval "$a"
    else
       args="${args} $1"
    fi
    shift 1
  done
  if [ ! -z "$args" ] ; then
     set `echo "$args" | awk '{ for(i=1;i<=NF;i++)print $i }'`
  fi
  return 0
}
#
#
##.........................................
#
splitUri() {
#----------------
#
  uri_hsmName=`expr "$1" : "\(.*\)\:.*"`
  uri_hsmInstance=`expr "$1" : ".*\:\/\/\(.*\)\/.*"`
  uri_store=`expr "$1" : ".*\/\?store=\(.*\)&group.*"`
  uri_group=`expr "$1" : ".*group=\(.*\)&bfid.*"`
  uri_bfid=`expr "$1" : ".*bfid=\(.*\)"`
#
  if [  \( -z "${uri_store}" \) -o \( -z "${uri_group}" \) -o \(  -z "${uri_bfid}" \) \
     -o \( -z "${uri_hsmName}" \) -o \( -z "${uri_hsmInstance}" \) ] ; then
     printerror "Illegal URI formal : $1"
     return 1
  fi
  return 0

}
#########################################################
#
echo "--------- $* `date`" >>${logFile}
#
#########################################################
#
createEnvironment() {

   if [ -z "${hsmBase}" ] ; then
      printerror "hsmBase not set, can't continue"
      return 1
   fi
   BASE=${hsmBase}/data
   if [ ! -d ${BASE} ] ; then
      printerror "${BASE} is not a directory or doesn't exist"
      return 1
   fi
}
##
#----------------------------------------------------------
doTheGetFile() {

   splitUri $1
   [ $? -ne 0 ] && return 1

   createEnvironment
   [ $? -ne 0 ] && return 1

   pnfsdir=${BASE}/$uri_hsmName/${uri_store}/${uri_group}
   pnfsfile=${pnfsdir}/$pnfsid

   cp $pnfsfile $filename 2>/dev/null
   if [ $? -ne 0 ] ; then
      printerror "Couldn't copy file $pnfsfile to $filename"
      return 1
   fi

   return 0
}
##
#----------------------------------------------------------
doTheStoreFile() {

   splitUri $1
   [ $? -ne 0 ] && return 1

   createEnvironment
   [ $? -ne 0 ] && return 1

   pnfsdir=${BASE}/$hsmName/${store}/${group}
   mkdir -p ${pnfsdir} 2>/dev/null
   if [ $? -ne 0 ] ; then
      printerror "Couldn't create $pnfsdir"
      return 1
   fi
   pnfsfile=${pnfsdir}/$pnfsid

   cp $filename $pnfsfile 2>/dev/null
   if [ $? -ne 0 ] ; then
      printerror "Couldn't copy file $filename to $pnfsfile"
      return 1
   fi

   return 0

}
##
#----------------------------------------------------------
doTheRemoveFile() {

   splitUri $1
   [ $? -ne 0 ] && return 1

   createEnvironment
   [ $? -ne 0 ] && return 1

   pnfsdir=${BASE}/$uri_hsmName/${uri_store}/${uri_group}
   pnfsfile=${pnfsdir}/$uri_bfid

   rm $pnfsfile 2>/dev/null
   if [ $? -ne 0 ] ; then
      printerror "Couldn't remove file $pnfsfile"
      return 1
   fi

   return 0
}
#########################################################
#
#  split arguments
#
  args=""
  while [ $# -gt 0 ] ; do
    if expr "$1" : "-.*" >/dev/null ; then
       a=`expr "$1" : "-\(.*\)" 2>/dev/null`
       key=`echo "$a" | awk -F= '{print $1}' 2>/dev/null`
         value=`echo "$a" | awk -F= '{for(i=2;i<NF;i++)x=x $i "=" ; x=x $NF ; print x }' 2>/dev/null`
       if [ -z "$value" ] ; then a="${key}=" ; fi
       eval "${key}=\"${value}\""
       a="export ${key}"
       eval "$a"
    else
       args="${args} $1"
    fi
    shift 1
  done
  if [ ! -z "$args" ] ; then
     set `echo "$args" | awk '{ for(i=1;i<=NF;i++)print $i }'`
  fi
#
#
if [ $# -lt 1 ] ; then
    printerror "Not enough arguments : ... put/get/remove ..."
    exit 1
fi
#
command=$1
pnfsid=$2
#
# !!!!!!  Hides a bug in the dCache HSM remove
#
if [ "$command" = "remove" ] ; then pnfsid="000000000000000000000000000000000000" ; fi
#
#
printout "Request for $command started `date`"
#
################################################################
#
if [ "$command" = "put" ] ; then
#
################################################################
#
  filename=$3
#
  if [ -z "$si" ] ; then
     printerror "StorageInfo (si) not found in put command"
     exit 5
  fi
#
  assignStorageInfo
#
  printStorageInfo
#
  if [ \( -z "${store}" \) -o \( -z "${group}" \) -o \( -z "${hsmName}" \) ] ; then
     printerror "Didn't get enough information to flush : hsmName = $hsmName store=$store group=$group pnfsid=$pnfsid "
     exit 3
  fi
#
  uri="$hsmName://$hsmName/?store=${store}&group=${group}&bfid=${pnfsid}"

  printout "Created identifier : $uri"

  doTheStoreFile $uri
  rc=$?
  if [ $rc -eq 0 ] ; then echo $uri ; fi

  printout "Request 'put' finished at `date` with return code $rc"
  exit $rc
#
#
################################################################
#
elif [ "$command" = "get"  ] ; then
#
################################################################
#
  filename=$3
  if [ -z "$uri" ] ; then
     printerror "Uri not found in arguments"
     exit 3
  fi
#
  printout "Got identifier : $uri"
#
  doTheGetFile $uri
  rc=$?
  printout "Request 'get' finished at `date` with return code $rc"
  exit $rc
#
################################################################
#
elif [ "$command" = "remove" ] ; then
#
################################################################
#
   if [ -z "$uri" ] ; then
      printerror "Illegal Argument error : URI not specified"
      exit 4
   fi
#
   printout "Remove uri = $uri"
   doTheRemoveFile $uri
   rc=$?
#
   printout "Request 'remove' finished at `date` with return code $rc"
   exit $rc
#
else
#
   printerror "Expected command : put/get/remove , found : $command"
   exit 1
#
fi]]></programlisting>
      </informalexample>

    </section>

</chapter>
