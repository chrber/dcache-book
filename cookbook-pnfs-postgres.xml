<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">     
    
<chapter id="cb-pnfs-postgres">
  <title>Moving the <pnfs/> Data from GDBM to PostgreSQL</title>

  
  
  <para>
    From version 1.6.6 of <dcache/> the distribution contains a
    version of the <pnfs/> server which uses a PostgreSQL database to
    store the namespace information instead of gdbm database
    files. The following guide will aid in updating to this server and
    converting the data from the gdbm files to the PostgreSQL
    database.
  </para>

  <section>
    <title>Preliminaries and Preparations</title>

    <para>
      Before converting the data and updating the server, a PostgreSQL
      server should be installed on the machine the <pnfs/> server is
      running on. In principle it is possible to run it on a separate
      server, however, this will most likely result in degraded
      performance and is not supported by this documentation. <pnfs/>
      might also use the same database server as other components of
      the <dcache/> instance. For a discussion of the usages of
      PostgreSQL by <dcache/> and its configuration see <xref
      linkend="cb-postgres"/>.
    </para>
    
    <para>
      Prepare the PostgreSQL server by creating a database user for
      the <pnfs/> server. It has to have permissions to create
      databases. We suggest to call it <literal>pnfsserver</literal>:

<screen><rootprompt/><command>su</command> - postgres
<userprompt/><command>createuser</command> --no-adduser --createdb pnfsserver</screen>

      Or use

<screen><rootprompt/><command>su</command> - postgres
<userprompt/><command>createuser</command> --no-adduser --createdb --pwprompt pnfsserver</screen>

      to set a password if PostgreSQL is configured more securely 
      as described in <xref linkend="cb-postgres"/>.
    </para>
    
    <para>
      The following procedure requires a downtime of the <pnfs/>
      server and therefore of the <dcache/> system.
    </para>
  </section>

  <section id="cb-pnfs-postgres-check1">
    <title>Checking the GDBM Database Files</title>

    <para>
      In the following, we will assume that the old <pnfs/> server
      software is installed below <filename
      class="directory">/opt/pnfs.3.1.10/pnfs/</filename> and the
      <pnfs/> databases are stored in <filename
      class="directory">/opt/pnfsdb/pnfs/databases/</filename>. These
      are the standard locations. However, they can be freely
      configured in <filename>/usr/etc/pnfsSetup</filename>.
      The actual locations of the database files can be found as follows

<screen><rootprompt/>. /usr/etc/pnfsSetup
<rootprompt/><command>cat</command> ${database}/D-* | cut -f 5 -d ':'</screen>

    </para>

    <para>
      Shut down the <pnfs/> server (after shutting down <dcache/>):

<screen><rootprompt/><command>/opt/pnfs.3.1.10/pnfs/bin/pnfs</command> stop</screen>

      This would be a good time to perform a backup of the database
      files in <filename
      class="directory">/opt/pnfsdb/pnfs/databases/</filename>. 
    </para>

    <para>
      Check the integrity of these GDBM database files as follows.
      First prepare the environment for the <pnfs/> tools as usual:

<screen><rootprompt/>. /usr/etc/pnfsSetup
<rootprompt/>PATH=${pnfs}/tools:$PATH</screen>

      Choose a suitable temporary directory <filename
      class="directory"><replaceable>tempDirOld</replaceable></filename>
      where the output of the scan commands is stored and create it

<screen><rootprompt/><command>mkdir</command> <replaceable>tempDirOld</replaceable>/</screen>

      Perform the
      following three commands for each of the database files in
      <filename
      class="directory">/opt/pnfsdb/pnfs/databases/</filename> (or
      whereever you found them as described above):

<screen><rootprompt/><command>md3tool</command> scan /opt/pnfsdb/pnfs/databases/<replaceable>dbName</replaceable> &gt; <replaceable>tempDirOld</replaceable>/<replaceable>dbName</replaceable>.scan 2&gt;&amp;1
<rootprompt/><command>md3tool</command> scandir /opt/pnfsdb/pnfs/databases/<replaceable>dbName</replaceable> &gt; <replaceable>tempDirOld</replaceable>/<replaceable>dbName</replaceable>.scandir 2&gt;&amp;1
<rootprompt/><command>md3tool</command> scandirs /opt/pnfsdb/pnfs/databases/<replaceable>dbName</replaceable> &gt; <replaceable>tempDirOld</replaceable>/<replaceable>dbName</replaceable>.scandirs 2&gt;&amp;1</screen>

      Have a look at the output. It should contain no error
      messages. You can do that with

<screen><rootprompt/><command>grep</command> -v "^ ID" <replaceable>tempDirOld</replaceable>/<replaceable>dbName</replaceable>.scan
<rootprompt/><command>grep</command> -v "^Scan" <replaceable>tempDirOld</replaceable>/<replaceable>dbName</replaceable>.scandir
<rootprompt/><command>grep</command> -v "^Dir" <replaceable>tempDirOld</replaceable>/<replaceable>dbName</replaceable>.scandirs</screen>

      The output of these three commands should look like 

<programlisting> Total Objects : 48
 Directories
   inode  : 5
   data   : 18
   hash   : 10
 Files
   inode  : 5
   data   : 5
   hash   : 0
 Links
   inode  : 0
   data   : 0
   hash   : 0
 Tags
   inode  : 4
   data   : 0
   hash   : 0
 Scanning DB id : 1
   External Reference at 0 : 000400000000000000001060 for d2
   External Reference at 0 : 000800000000000000001060 for d6
   External Reference at 0 : 000B00000000000000001060 for d9
   External Reference at 0 : 000700000000000000001060 for d5
   External Reference at 0 : 000200000000000000001060 for d0
   External Reference at 0 : 000500000000000000001060 for d3
   External Reference at 0 : 000900000000000000001060 for d7
   External Reference at 0 : 000300000000000000001060 for d1
   External Reference at 0 : 000A00000000000000001060 for d8
   External Reference at 0 : 000600000000000000001060 for d4
 Scanning DB id : 1</programlisting>

      It should not contain any error messages. The lines starting
      with <quote><literal>External Reference</literal></quote> should
      contain the <pnfs/> IDs and names of the directories which are
      the root of a new database created as described in <xref
      linkend="cf-pnfs-db"/>.
    </para>

    <para>
      Only if there are no errors or unusual output for all of the
      database files of the <pnfs/> server you can continue with the
      conversion to the PostgreSQL version of <pnfs/>. In the case of
      errors the conversion will most likely result in loss of
      data. In this case, stay with the old version of the <pnfs/>
      server. Even though some parts of the database files are broken
      - as the scan reveals - the system will continue to run
      fine. Restart the server with

<screen><rootprompt/><command>/opt/pnfs.3.1.10/pnfs/bin/pnfs</command> start</screen>

      since the conversion as described below will not work porperly.  In this
      case contact <email>support@dcache.org</email> for guidance in converting to
      PostgreSQL and remember to attach the output of the grep commands given above.
    </para>
  </section>

  <section>
    <title>Updating the <pnfs/> Software</title>

    <para>
      Move the <pnfs/> databases to a secure backup directory
      <replaceable>backupDir</replaceable>:

<screen><rootprompt/><command>mv</command> /opt/pnfsdb/pnfs/databases  <replaceable>backupDir</replaceable>/databases</screen>

      It is also a good idea to backup the central configuration file
      <filename>/usr/etc/pnfsSetup</filename>:

<screen><rootprompt/><command>cp</command> /usr/etc/pnfsSetup <replaceable>backupDir</replaceable>/pnfsSetup</screen>

    </para>

    <para>
      Remove the old version of the <pnfs/> software:

<screen><rootprompt/><command>rpm</command> -e pnfs</screen>

    </para>

    <para>
      Now create the empty files with the names of the original
      database files. Only the names of these files will be used by
      the new <pnfs/> server.  The conversion preformed below will create
      a new database in the PostgreSQL server for each of the original
      database files. If <filename>admin</filename>,
      <filename>data1</filename>, ... , <filename>dataN</filename> are
      the original database file names, then do

<screen><rootprompt/><command>mkdir</command> /opt/pnfsdb/pnfs/databases
<rootprompt/><command>cd</command> /opt/pnfsdb/pnfs/databases
<rootprompt/><command>touch</command> admin data1 data2 ... dataN</screen>
    </para>

    <para>
      Adjust the central configuration file
      <filename>/usr/etc/pnfsSetup</filename>: Change the location of the
      <pnfs/> software in the line

<programlisting>pnfs=/opt/pnfs.3.1.10/pnfs</programlisting>

      to   

<programlisting>pnfs=/opt/pnfs</programlisting>

      and add a line reading 

<programlisting>export dbConnectString="user=pnfsserver"</programlisting>

      and change the PostgreSQL username if you did not use our suggestion 
      <literal>pnfsserver</literal>. If you have set a password when creating
      the user above, use

<programlisting>export dbConnectString="user=pnfsserver password=<replaceable>yourPassword</replaceable>"</programlisting>

    </para>

    <note>
      <para>
        Starting with the PostgreSQL version of <pnfs/> the software directory
        will not depend on the version anymore since RPM makes shure that only
        one version of <pnfs/> is installed.
      </para>
    </note>

    <para>
      Install the PostgreSQL version of <pnfs/> with something like

<screen><rootprompt/><command>rpm</command> -ivh pnfs-postgresql-3.1.10-1.i386.rpm</screen>

      it contains everything necessary for the conversion as described in the
      next section
    </para>

  </section>

  <section>
    <title>Conversion of the Databases</title>

    <para>
      Prepare the environment for the <pnfs/> tools as usual:

<screen><rootprompt/>. /usr/etc/pnfsSetup
<rootprompt/>PATH=${pnfs}/tools:$PATH</screen> 

      Note that you have to do this now even if you did it before because the
      content of <filename>/usr/etc/pnfsSetup</filename> changed.
    </para>

    <para>
      The conversion of the GDBM file
      <filename><replaceable>backupDir</replaceable>/databases/<replaceable>gdbmFile</replaceable></filename> 
      is done with the following command:

<screen><rootprompt/><command>gdbm2psql</command> -r -o -i <replaceable>backupDir</replaceable>/databases/<replaceable>gdbmFile</replaceable></screen>

      It is necessary to use the full path to the file. A new database
      in the PostgreSQL server will be created and the data from the
      GDBM file will be written into it. A typical output is

<programlisting>Connection string: dbname=template1 user=pnfsserver
Connection string: dbname=admin user=pnfsserver
WARNING:  there is no transaction in progress
Put record #1 into the database...time=0
key 000000000000xxxxxxxxxxxx is found at 1310
There are 3671 records in the database.</programlisting>


      The conversion script also takes a bit of time, but is fairly
      quick. In fact, you may exceed PostgreSQL's checkpointing
      capability, in which case edit the
      <filename><replaceable>database_directory_name</replaceable>/data/postgresql.conf</filename>
      file and increase the number of
      <literal>checkpoint_segments</literal> (for example from 3 to
      10).
    </para>
      
    <para>
      To speed up the conversion the program does not create the
      database key, so you have to do it in a separate step. For each
      database created during the conversion run

<screen><rootprompt/><command>psql</command> -U pnfsserver -c 'ALTER TABLE pnfs ADD primary key (pnfsid)' <replaceable>dbName</replaceable></screen>

      (or use the script
      <filename>${pnfs}/tools/make-key.sh</filename>).  This also can
      take a while if the files were large.
    </para>

  </section>

  <section>
    <title>Testing the Converted Databases</title>

    <para>
      Testing the converted databases before starting the new <pnfs/>
      server is very essential. If any discrepancies are detected the
      system should be reverted to the old version of <pnfs/> using
      the old database files. The testing is performed by repeating
      the procedure described in <xref
      linkend="cb-pnfs-postgres-check1"/> for the new databases and
      comparing the results with those of the old tests. For smaller
      installations this is done with

<screen><rootprompt/><command>conversion-scan.sh</command> <replaceable>oldPnfsDatabaseDir</replaceable> <replaceable>newPnfsDatabaseDir</replaceable></screen>

      e.g.

<screen><rootprompt/><command>conversion-scan.sh</command> <replaceable>backupDir</replaceable>/databases /opt/pnfsdb/pnfs/databases</screen>

      The output of the scans performed by this script can be found in
      <filename>/tmp/pnfs-conversion-scan-<replaceable>PID</replaceable>/old/</filename>
      and
      <filename>/tmp/pnfs-conversion-scan-<replaceable>PID</replaceable>/new/</filename>. 
    </para>

    <para>
      For larger installations it is probably better to perform the
      tests by hand as described in <xref
      linkend="cb-pnfs-postgres-check1"/>. The old version of the
      <command>md3tool</command> command is provided in the
      <literal>pnfs-postgresql</literal> package for convenience
      (called <command>md3tool_gdbm</command>.)
    </para>

    <para>
      If all the tests succeeded, the <pnfs/> server may be started
      as usual:

<screen><rootprompt/><command>${pnfs}/bin/pnfs</command> start</screen>

      Make shure that the PostgreSQL server is always started before
      the <pnfs/> server - especially at system start-up. You also
      might have to change the path to the <pnfs/> software from
      <filename class="directory">/opt/pnfs.3.1.10/pnfs/</filename> to
      <filename class="directory">/opt/pnfs/</filename> in a start-up
      script.
    </para>

  </section>
  
  <unfinished>
  <screen>

   If there is another Postgres installed on your machine, make sure root's path is 
   set so that executables, esp. psql, postmaster, and pg_ctl, are called from the
   V8.x.x Postgres that you intend to use for dCache. (You will be doing most of this
   as root). Another thing is to make sure that the various libpg.so libraries are 
   not invoked from the other Postgres distribution. "locate libpg.so" will show which
   ones are on your system. Set LD_LIBRARY_PATH for root to insure that the "pnfs" 
   Postgress libs are seen first! 

   Note that for performance reasons it is recommended that only one Postgres 
   be run on the pnfs server. 

# TYPE  DATABASE    USER        CIDR-ADDRESS          METHOD

# "local" is for Unix domain socket connections only
local   all         postgres                          ident sameuser
local   all         pnfsserver                        password
local   all         all                               md5
# IPv4 local connections:
host    all         all         127.0.0.1/32          md5
# IPv6 local connections:
host    all         all         ::1/128               md5


pg_ctl reload

2. Create postgres user with the name you will be using to run pnfs server.
   Make sure it has "CREATEDB" privilege.

      psql -U postgres template1 -c "CREATE USER johndoe with CREATEDB"

      dropuser pnfsserver

      createuser --no-adduser --createdb --pwprompt pnfsserver

3. Shutdown the PNFS server.


4. Download from dcache.org and unpack postgres version of PNFS software from the tarfile 
        tar xfz pnfs.3.1.10-f8.tgz
   Download from dcache.org and unpack the tar file pnfs-conversion-kit.tgz
       cd pnfs-conversion-kit

5. Get the PNFS database directory out of the way:
       mv /opt/pnfsdb/pnfs/databases  <replaceable>backupDir</replaceable>/databases

6. Now create the empty files with the original databases file names. These files will be used
   by pnfs server as the nameholders. Postgres creates a new database for each of the original 
   database files. If admin, data1, data2, ... dataN are the original database file
   names, then

        mkdir /opt/pnfsdb/pnfs/databases
        cd /opt/pnfsdb/pnfs/databases
	touch admin data1 data2 ... dataN

7. Scan all the databases using script v3_1_10-f4/scan.sh
        for example:
        cd v3_1_10-f4

        cp scan.sh /opt/pnfs.3.1.10/pnfs/tools/
        cd /opt/pnfs.3.1.10/pnfs/tools/

        ./scan.sh <replaceable>backupDir</replaceable>/databases/admin
        ...............


#! /bin/bash

if [ ! -d /tmp/Scan0 ] ; then
    mkdir /tmp/Scan0
fi

bn=`basename $1`

echo    "md3tool scan $1 &gt; /tmp/Scan0/${bn}.scan"
./md3tool scan $1 &gt; /tmp/Scan0/${bn}.scan 2&gt;&amp;1
grep -v "^ ID" /tmp/Scan0/${bn}.scan
echo    "md3tool scandir $1 &gt; /tmp/Scan0/${bn}.scandir"
./md3tool scandir $1 &gt; /tmp/Scan0/${bn}.scandir 2&gt;&amp;1
grep -v "^Scan" /tmp/Scan0/${bn}.scandir
echo    "md3tool scandirs $1 &gt; /tmp/Scan0/${bn}.scandirs"
./md3tool scandirs $1 &gt; /tmp/Scan0/${bn}.scandirs 2&gt;&amp;1
grep -v "^Dir" /tmp/Scan0/${bn}.scandirs




md3tool scan /opt/pnfs-databases-old/admin &gt; /tmp/Scan0/admin.scan
 Total Objects : 75
 Directories
   inode  : 11
   data   : 21
   hash   : 22
 Files
   inode  : 8
   data   : 8
   hash   : 0
 Links
   inode  : 2
   data   : 2
   hash   : 0
 Tags
   inode  : 0
   data   : 0
   hash   : 0
md3tool scandir /opt/pnfs-databases-old/admin &gt; /tmp/Scan0/admin.scandir
 Scanning DB id : 0
   External Reference at 0 : 000100000000000000001060 for data
md3tool scandirs /opt/pnfs-databases-old/admin &gt; /tmp/Scan0/admin.scandirs
 Scanning DB id : 0


        The script will put the logfiles into /tmp/Scan0 directory. Note that the 
	scan takes some time. 

  

8. Check if there are any errors in the logfiles
        *If you see any errors in the scan logs you can not proceed with the conversion!*
        *You must stop, investigate the problem and fix it first!*

    Various "grep -v" commands are useful for checking the logfiles, which can be fairly
    large. For example:
	grep -v "^ ID" /tmp/Scan0/db_name.scan
	grep -v ^Scan /tmp/Scan0/db_name.scandir
	grep -v ^Dir /tmp/Scan0/db_name.scandirs

    ...all produce a small amount of output (if no errors!), and also give useful 
    information, like the number of file records in the original database. 

9. If the scan was successful for *all* databases then run the conversion script for each database:

          export dbConnectString="user=pnfsserver password=test"

        cd ../v3_1_10-f8
        ./g2psql.sh <replaceable>backupDir</replaceable>/databases/admin
        ...............
   By default the program uses username "postgres" to connect to the postgres server. If you plan
   to use some other account to run the server you have to specify it using the shell environment:
        export dbConnectString="user=johndoe"


   The conversion script also takes a bit of time, but is fairly quick. In fact, you 
   may exceed Postgres's checkpointing capability, in which case edit the postgresql.conf
   file and increase the number of checkpoint_segments (for example from 3 to 10).

10. To speed up the conversion the program does not create the database key, so you have to do it
    in a separate step. For each database created during the conversion run script make-key.sh:
        ./make-key.sh admin
        ...............

        psql -U pnfsserver -c 'ALTER TABLE pnfs ADD primary key (pnfsid)' admin

	This also can take a while if the files were large.

11. Scan all converted databases using script v3_1_10-f8/scan.sh
        for example:
        cd v3_1_10-f8
        ./scan.sh /opt/pnfsdb/pnfs/databases/admin
        ...............

        The script will put the logfiles into /tmp/Scan1 directory

12.  Check if there are any errors in the logfiles
      *If you see any errors in the scan logs you can not proceed with the conversion!*
        *You must stop, investigate the problem and fix it first!*

13. Compare the logfiles from the directories  /tmp/Scan0 and /tmp/Scan1
        They *must* be identical!


14. Change the pnfs location in the configuration file /usr/etc/pnfsSetup
        pnfs=/opt/pnfs.3.1.10/pnfs  to   pnfs=/opt/pnfs.3.1.10-f8/pnfs

15. At that point you have everything ready to start the new server. Make sure that 
    you have changed the pnfs location name to /opt/pnfs.3.1.10-f8/pnfs in your 
    startup scripts pnfs/bin/pnfs and $pnfs/tools/pnfs.server, then execute 

	$pnfs/bin/pnfs start


########################################## COMPANION:


 Das folgende sniplet in pnfs.batch kann
 zwischen companion und nicht companion
 wechseln, abhaengig von einer variablen
 im dCache setup.  (cacheInfo)
 Fehlt sie ganz, wird pnfs fuer cacheinfo benutzt
 Hat sie einen wert other than 'companion' wird
 pnfs fuer cacheinfo benutzt. Ist der wert
 'companion' wird die databank benutzt. Vergleich bitte
 die PnfsMangerV3 optionen noch mal mit deinen.
 Ich hab mich nur auf den compantion konzentriert
 vielleicht fehlt noch eine.

 Noch zu beachten bei companion
  1)  es wird loop back interface benutzt
  2) srmDbHost muss im dCacheSetup auch gesetzt sein
  3) 'createdb dcache' und 'createuser srmdcache'
  4) cacheinfo table muss auch hergestellt werden
------------------------------------------------------
DROP TABLE cacheinfo;
DROP INDEX pool_inx;
DROP INDEX pnfs_inx;



CREATE TABLE cacheinfo (
 pnfsid CHAR(24)  NOT NULL,
 pool VARCHAR(255)  NOT NULL,
 ctime TIMESTAMP NOT NULL,
 UNIQUE(pnfsid, pool)
);

create index pool_inx on cacheinfo (pool);
create index pnfs_inx on cacheinfo (pnfsid);
-----------------------------------------------------------------

-------------------- pnfs.batch (only partially) -----------------------------------

#
#  if
#      cacheInfo=companion
#            ==>  cacheInfoProvider=diskCacheV111.namespace.provider.SQLCacheLocationProviderFactory
#  else if
#      cacheInfo=<replaceable>other or missing</replaceable>
#            ==>  cacheInfoProvider=diskCacheV111.namespace.provider.BasicNameSpaceProviderFactory
#  -p.
#
onerror continue
set env cacheInfoProvider diskCacheV111.namespace.provider.BasicNameSpaceProviderFactory
define context setcontext.exe endDefine
  set env cacheInfoProvider diskCacheV111.namespace.provider.SQLCacheLocationProviderFactory
endDefine
eval ${cacheInfo} companion ==
exec context setcontext.exe -run -ifok=rc
onerror shutdown
#
set env srmDbHost localhost
#
create diskCacheV111.namespace.PnfsManagerV3 PnfsManager \
       "diskCacheV111.util.OsmInfoExtractor \
        -enableLargeFileSimulation \
        -storeFilesize  \
        -cmRelay=broadcaster  \
        -threads=4 \
        -default=${defaultPnfsServer} \
        -pnfs=${pnfs} \
        -namespace-provider=diskCacheV111.namespace.provider.BasicNameSpaceProviderFactory \
        -cachelocation-provider=${cacheInfoProvider} \
        -cachelocation-provider-dbURL=jdbc:postgresql://${srmDbHost}/dcache \
        -cachelocation-provider-jdbcDrv=org.postgresql.Driver \
        -cachelocation-provider-dbUser=srmdcache \
        -cachelocation-provider-dbPass=srmdcache"
#


--------------------------------------------------------------------------------------------- 




    </screen>
  </unfinished>
  
</chapter>
