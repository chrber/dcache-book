<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">     

<chapter id="cf-pnfs">
  <title>Configuration in PNFS</title>
  
  <para>
    This chapter gives background information about <pnfs/>, the
    filesystem, <dcache/> is based on. Only the aspects of <pnfs/>
    relevant to <dcache/> will be explained here. <!-- For a complete
    documentation, refer to the <ulink
    url="http://www-pnfs.desy.de/"><pnfs/> homepage</ulink>. -->
  </para>

  <section id="cf-pnfs-use">
    <title>The Use of <pnfs/> in <dcache/></title>

    <para>
      <dcache/> uses <pnfs/> as a filesystem and for storing
      meta-data. <pnfs/> is a filesystem not designed for storage of
      actual files. Instead, <pnfs/> manages the filesystem hierarchy
      and standard meta-data of a UNIX filesystem. In addition, other
      applications (as for example <dcache/>) can use it to store
      their meta-data. <pnfs/> keeps the complete information in a
      database.
    </para>

    <para>
      <pnfs/> implements an NFS server. All the meta-data can be
      accessed with a standard NFS client, like the one in the Linux
      kernel. After mounting, normal filesystem operations work
      fine. However, IO operations on the actual files in the <pnfs/>
      will normally result in an error. 
    </para>

    <para>
      As a minimum, the <pnfs/> filesystem needs to be mounted only by
      the server running the <dcache/> core services. In fact, the
      <pnfs/> server has to run on the same system. For details see
      <xref linkend="cf-pnfs-access"/>. 
    </para>
      
    <para>
      The <pnfs/> filesystem may also be mounted by clients. This
      should be done by

<screen><rootprompt/>mount -o intr,hard,rw <replaceable>pnfs-server</replaceable>:/pnfs /pnfs/<replaceable>site.de</replaceable></screen>

      (assuming the system is configured as described in the
      installation instructions).  Users may then access the meta-data
      with regular filesystem operations, like <command>ls
      -l</command>, and by the <pnfs/>-specific operations described
      in the following sections. The files themselves may then be
      accessed with the <dcap/> protocol (see <xref
      linkend="dCacheBook"/> Client Access and Protocols). 
    </para>

    <para>
      Mounting the <pnfs/> filesystem is not necessary for client
      access to the <dcache/> system if URLs are used to refer to
      files.  In the grid context this is the preferred usage. 
    </para>

  </section>

  <section id="cf-pnfs-commands">
    <title>Communicating with the <pnfs/> Server</title>

    <para>
      Many configuration parameters of <pnfs/> and the
      application-specific meta-data is accessed by reading, writing,
      or creating files of the form
      <filename>.(<replaceable>command</replaceable>)(<replaceable>para</replaceable>)</filename>.
      For example, the following prints the <pnfs/>-ID of the file
      <filename>/pnfs/site.de/some/dir/file.dat</filename>:

      <screen><userprompt/>cat /pnfs/site.de/any/sub/directory/'.(id)(file.dat)' 
0004000000000000002320B8
<userprompt/></screen> 

      From the point of view of the NFS protocol, the file
      <filename>.(id)(file.dat)</filename> in the directory <filename
      class="directory">/pnfs/site.de/some/dir/</filename> is
      read. However, <pnfs/> interprets it as the command
      <literal>id</literal> with the parameter
      <literal>file.dat</literal> executed in the directory
      <filename>/pnfs/site.de/some/dir/</filename>. The quotes are
      important, because the shell would otherwise try to interpret
      the parentheses.
    </para>

    <para>
      Some of these command-files have a second parameter in a third
      pair of parentheses. Note, that files of the form
      <filename>.(<replaceable>command</replaceable>)(<replaceable>para</replaceable>)</filename>
      are not really files. They are not shown when listing
      directories with <command>ls</command>. However, the
      command-files are listed when they appear in the argument list
      of <command>ls</command> as in

<screen><userprompt/><command>ls</command> -l '<filename>.(tag)(sGroup)</filename>'
-rw-r--r--   11 root     root            7 Aug  6  2004 .(tag)(sGroup)</screen>

      Only a subset of file operations are allowed on
      these special command-files. Any other operation will result in
      an appropriate error. Beware, that files with names of this form
      might accidentally be created by typos.  They will then be shown
      when listing the directory.
    </para>

  </section>

  <section id="cf-pnfs-ids">
    <title><pnfs/>-IDs</title>

    <para>
      Each file in <pnfs/> has a unique 12 byte long <pnfs/>-ID. This
      is comparable to the inode number in other filesystems. The
      <pnfs/>-ID used for a file will never be reused, even if the
      file is deleted. <dcache/> uses the <pnfs/>-ID for all internal
      references to a file. 
    </para>
    
    <para>
      The <pnfs/>-ID of the file
      <filename><replaceable>filename</replaceable></filename> can be
      obtained by reading the command-file
      <filename>.(id)(<replaceable>filename</replaceable>)</filename>
      in the directory of the file.
    </para>
    
    <para>
      A file in <pnfs/> can be referred to by <pnfs/>-ID for most
      operations. For example, the name of a file can be obtained from
      the <pnfs/>-ID with the command <literal>nameof</literal> as follows:

<screen><userprompt/>cd /pnfs/site.de/any/sub/directory/
<userprompt/>cat '.(nameof)(0004000000000000002320B8)'
file.dat</screen>

      And the <pnfs/>-ID of the directory it resides in is obtained by:

<screen><userprompt/>cat '.(parent)(0004000000000000002320B8)'
0004000000000000001DC9E8
</screen>

      This way, the complete path of a file may be obtained starting
      from the <pnfs/>-ID. Precisely this is done by the tool
      <command>pathfinder</command>:

<screen><userprompt/>. /usr/etc/pnfsSetup
<userprompt/>PATH=$PATH:$pnfs/tools
<userprompt/>cd /pnfs/site.de/another/dir/
<userprompt/>pathfinder 0004000000000000002320B8
0004000000000000002320B8 file.dat
0004000000000000001DC9E8 directory
000400000000000000001060 sub
000100000000000000001060 any
000000000000000000001080 usr
000000000000000000001040 fs
000000000000000000001020 root
000000000000000000001000 -
000000000000000000000100 -
000000000000000000000000 -
/root/fs/usr/any/sub/directory/file.dat</screen>

      The first two lines configure the <pnfs/>-tools correctly. The
      path obtained by <command>pathfinder</command> does not agree
      with the local path, since the latter depends on the mountpoint
      (in the example <filename
      class="directory">/pnfs/site.de/</filename>). The <pnfs/>-ID
      corresponding to the mountpoint may be obtained with

<screen><userprompt/>cat '.(get)(cursor)'
dirID=0004000000000000001DC9E8
dirPerm=0000001400000020
mountID=000000000000000000001080
</screen>
      
      The <literal>dirID</literal> is the <pnfs/>-ID of the current
      directory and <literal>mountID</literal> that of the
      mountpoint. In the example, the <pnfs/> server path <filename
      class="directory">/root/fs/usr/</filename> is mounted on
      <filename class="directory">/pnfs/site.de/</filename>.
    </para>
  </section>

  <section id="cf-pnfs-tags">
    <title>Directory Tags</title>
    
    <para>
      In the <pnfs/> filesystem, each directory has a number of
      tags. The existing tags may be listed with

<screen><userprompt/><command>cat</command> '<filename>.(tags)()</filename>'
.(tag)(OSMTemplate)
.(tag)(sGroup)</screen>

      and the content of a tag can be read with

<screen><userprompt/><command>cat</command> '<filename>.(tag)(OSMTemplate)</filename>'
StoreName myStore</screen>

      A nice trick to list all tags with their contents is 

      <screen><userprompt/><userinput><command>grep</command> "" $(cat ".(tags)()")</userinput>
.(tag)(OSMTemplate):StoreName myStore
.(tag)(sGroup):STRING
</screen>
    </para>

    <para>
      Directory tags may be used within <dcache/> to control which
      pools are used for storing the files in the directory (see <xref
      linkend="cf-pm-psu"/>). They might also be used by a
      <firstterm>tertiary storage system</firstterm> for similar
      purposes (e.g. controlling the set of tapes used for the files
      in the directory).
    </para>

    <para>
      Even if the directory tags are not used to control the bahaviour
      of <dcache/>, some tags have to be set for the directories where
      <dcache/> files are stored. The installation procedure takes
      care of this: In the directory <filename
      class="directory">/pnfs/<replaceable>site.de</replaceable>/data/</filename>
      two tags are set to default values:

<screen><userprompt/><userinput><command>cd</command> /pnfs/<replaceable>site.de</replaceable>/data/</userinput>
<userprompt/><userinput><command>grep</command> "" $(cat ".(tags)()")</userinput>
.(tag)(OSMTemplate):StoreName myStore
.(tag)(sGroup):STRING
</screen>
    </para>

    <para>
      The following directory tags appear in the <dcache/> context:
      <table>
	<title>Directory Tags for <dcache/></title>
	<tgroup cols="2">
	  <colspec colnum="1" colname="tag" colwidth="130" align="left"/>
	  <colspec colnum="2" colname="describtion" align="justify"/>
	  <tbody>
	    <row>
	      <entry>OSMTemplate</entry>
	      <entry>
		Contains one line of the form
		<quote><literal>StoreName
		<replaceable>storeName</replaceable></literal></quote>
		and specifies the name of the store which is used by
		<dcache/> to construct the <glossterm
		linkend="gl-storage_class">storage class</glossterm>
		if the <glossterm linkend="gl-hsm_type">HSM
		type</glossterm> is <literal>osm</literal>.
	      </entry>
	    </row>
	    <row>
	      <entry>sGroup</entry>
	      <entry>
		The storage group is also used to construct the <glossterm
		linkend="gl-storage_class">storage Class</glossterm>
		if the <glossterm linkend="gl-hsm_type">HSM
		type</glossterm> is <literal>osm</literal>.
	      </entry>
	    </row>
	    <row>
	      <entry>cacheClass</entry>
	      <entry>
		The cache class is only used to control on which pools
		the files in a directory may be stored, while the
		storage class (constructed from the two above tags)
		might also be used by the HSM. The cache class is only
		needed if the above two tags are already fixed by HSM
		usage and more flexibility is needed.
	      </entry>
	    </row>
	    <row>
	      <entry>hsmType</entry>
	      <entry>
		The <glossterm linkend="gl-hsm_type">HSM
		type</glossterm> is normally determined from the other
		existing tags. E.g. if the tag
		<literal>OSMTemplate</literal> exists, HSM type
		<literal>osm</literal> is assumed. With this tag it
		can be set explicitly. An class implementing that HSM
		type has to exist. Currently the only implementations
		are <literal>osm</literal> and
		<literal>enstore</literal>.
	      </entry>
	    </row>
	    <row>
	      <entry>hsmInstance</entry>
	      <entry>
		If not set, the HSM instance will be the same as the
		HSM type. Setting this tag will only change the name
		as used in the <glossterm
		linkend="gl-storage_class">storage class</glossterm>
		and in the pool commands.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </para>

    <para>
      There are more tags used by <dcache/> if the HSM type
      <literal>enstore</literal> is used.
    </para>

    <para>
      When creating or changing directory tags by writing to the
      command-file as in

<screen><userprompt/><command>echo</command> '<replaceable>content</replaceable>' > '<filename>.(tag)(<replaceable>tagName</replaceable>)</filename>'</screen>

      one has to take care not to treat the command-files in the
      same way as regular files, because tags are different from files
      in the following aspects:
      <orderedlist>
	<listitem>
	  <para>
	    The <replaceable>tagName</replaceable> is limited to 62
	    characters and the <replaceable>content</replaceable> to
	    512 bytes. Writing more to the command-file, will be
	    silently ignored.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    If a tag which does not exist in a directory is created by
	    writing to it, it is called a <emphasis>primary</emphasis>
	    tag.  
	  </para>
	  <para>
	    Removing a primary tag invalidates this tag. An
	    invalidated tag behaves as if it does not exist. All
	    filesystem IO operations on that tag produce an
	    <quote>File not found</quote> error. However, a lookup
	    operation ( e.g. ls) will show this tag with a 0 byte
	    size. An invalidated tag can be revalidated with the help
	    of the tool <command>repairTag.sh</command> in the
	    <filename class="directory">tools/</filename> directory of
	    the <pnfs/> distribution. It has to be called in the
	    directory where the primary tag was with the tag name as
	    argument.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Tags are <emphasis>inherited</emphasis> from the parent
	    directory by a newly created directory. Changing a primary
	    tag in one directory will change the tags inherited from
	    it in the same way, even if it is invalidated or
	    revalidated. Creating a new primary tag in a directory
	    will not create a inherited tag in its subdirectories.
	  </para>
	  <para>
	    Moving a directory within the <pnfs/> filesystem will not
	    change the inheritance. Therefore, a directory does not
	    necessarily inherit tags from its parent
	    directory. Removing an inherited tag does not have any
	    effect.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Writing to an inherited tag in the subdirectory will break
	    the inheritance-link. A
	    <emphasis>pseudo-primary</emphasis> tag will be created.
	    The directories which inherited the old (inherited) tag
	    will inherit the pseudo-primary tag.  A pseudo-primary tag
	    behaves exactly like a primary tag, except that the
	    original inherited tag will be restored if the
	    pseude-primary tag is removed.
	  </para>
	</listitem>
      </orderedlist>
    </para>

    <para>
      If directory tags are used to control the behaviour of <dcache/>
      and/or a tertiary storage system, it is a good idea to plan the
      directory structure in advance, thereby considering the
      necessary tags and how they should be set up. Moving directories
      should be done with great care or even not at all. Inherited
      tags can only be created by creating a new directory.
    </para>

  </section>

  <section id="cf-pnfs-wormholes">
    <title>Global Configuration with <glossterm linkend="gl-wormhole">Wormholes</glossterm></title>

    <para>
      <pnfs/> provides a way to distribute configuration information
      to all directories in the <pnfs/> filesystem. It can be accessed
      in a subdirectory <filename
      class="directory">.(config)()</filename> of any
      <pnfs/>-directory. It behaves similar to a hardlink. 
    </para>

  </section>
  
  <section id="cf-pnfs-metadata">
    <title>Meta Data in <pnfs/></title>

    <para>
      all other command-files: fset set use puse
    </para>

  </section>
  
  <section id="cf-pnfs-ac">
    <title>Access Control</title>
    
    <para>
      How to restrict access to <pnfs/> on a host basis.
      
      TODO: somewhere: Passwort in batch file for SRM, Pin, ... (chmod 600)
    </para>

    <para>
      The file
      <filename>/pnfs/fs/admin/etc/exports/<replaceable>hostIP</replaceable></filename>
      contains one line per NFS mount point which contain the
      following four fields:
      <itemizedlist>
	<listitem>
	  <para>
	    Mount point for NFS (the part after the colon in e.g.
	    host:/mountpoint)
	  </para>
	</listitem>

	<listitem>
	  <para>
	    The virtual PNFS path which is mounted
	  </para>
	</listitem>
	
	<listitem>
	  <para>
	    A number: 0: all permissions 30: restricted
	  </para>
	</listitem>
	
	<listitem>
	  <para>
	    Options (usually: nooptions)
	  </para>
	</listitem>
      </itemizedlist>
    </para>

  </section>
  
  <section id="cf-pnfs-db">
    <title>The Databases of <pnfs/></title>

    <para>
      TODO
    </para>

  </section>

  <section id="cf-pnfs-details" userlevel="details">
    <title>Details</title>
    
    <section id="cf-pnfs-access">
      <title>Access of the <dcache/> Server to <pnfs/></title>
      
      <para>TODO: Which cells access PNFS how?</para>
      
    </section>

    <unfinished>
      <para><literal>.(showid)(<replaceable>pnfs-ID</replaceable>)</literal></para>
    </unfinished>
      
  </section>
</chapter>
